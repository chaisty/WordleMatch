@page "/"
@inject HttpClient Http
@inject IJSRuntime JSRuntime
@inject WordleHelper.Services.WordleFilterService FilterService
@inject WordleHelper.Services.WordleStrategyService StrategyService
@using WordleHelper.Services
@using LetterState = WordleHelper.Services.WordleFilterService.LetterState

<PageTitle>Wordle Match</PageTitle>

<div class="wordle-container">
    <h1>Wordle Match</h1>

    <input type="text" id="mobile-keyboard-input" class="mobile-keyboard-input" inputmode="text" autocapitalize="off" autocomplete="off" autocorrect="off" spellcheck="false" />

    @* Display previous guesses *@
    @for (int guessIndex = 0; guessIndex < previousGuesses.Count; guessIndex++)
    {
        var currentGuessIndex = guessIndex;
        var (guessLetters, guessStates) = previousGuesses[guessIndex];
        <div class="previous-guess-row">
            <div class="letter-boxes previous-guess">
                @for (int i = 0; i < 5; i++)
                {
                    int index = i;
                    <div class="letter-box-container">
                        <div class="letter-box @GetLetterClassForState(guessStates[index])">
                            @(guessLetters[index] == ' ' ? "" : guessLetters[index].ToString().ToUpper())
                        </div>
                    </div>
                }
            </div>
            <button class="delete-guess-btn" @onclick="() => RemoveGuess(currentGuessIndex)" title="Remove this guess">×</button>
        </div>
    }

    @* Current entry row *@
    <div class="entry-row">
        <div class="letter-boxes" id="letter-boxes-container">
            @for (int i = 0; i < 5; i++)
            {
                int index = i;
                <div class="letter-box-container">
                    <div class="letter-box @GetLetterClass(index) @GetFocusClass(index) @(lockedPositions[index] ? "locked" : "")" @onclick="() => SetFocus(index)">
                        @(letters[index] == ' ' ? "" : letters[index].ToString().ToUpper())
                    </div>
                    @if (letters[index] != ' ' && !lockedPositions[index])
                    {
                        <div class="button-group">
                            <button class="state-button @GetStateButtonClass(index)"
                                    title="@GetStateButtonTooltip(index)"
                                    @onclick="() => CycleState(index)"></button>
                        </div>
                    }
                </div>
            }
        </div>
        <button class="add-guess-btn" @onclick="AddGuess" title="add new guess">+</button>
    </div>

    <div class="instructions">
        Type letters from your Wordle guesses. Lowercase = excluded letter (white), Uppercase = letter in word but wrong position (yellow). Click the button to cycle through states. Press Space to leave a box empty (wildcard).
    </div>

    <div class="recommendations-section">
        <div class="recommendations-header">
            <span class="recommendations-label">Recommendations:</span>
            <div class="mode-toggle">
                <button class="mode-btn @(strategyMode == StrategyMode.Off ? "active" : "")" @onclick="() => SetStrategyMode(StrategyMode.Off)">Off</button>
                @* Temporarily hidden due to performance issues - see docs/recommendation-optimization-analysis.md *@
                @* <button class="mode-btn @(strategyMode == StrategyMode.Normal ? "active" : "")" @onclick="() => SetStrategyMode(StrategyMode.Normal)">Normal</button> *@
                <button class="mode-btn @(strategyMode == StrategyMode.Hard ? "active" : "")" @onclick="() => SetStrategyMode(StrategyMode.Hard)">Hard</button>
            </div>
            @if (isLoadingRecommendations)
            {
                <span class="loading-indicator">Calculating...</span>
            }
            else if (strategyMode != StrategyMode.Off && recommendations != null && recommendations.Any())
            {
                <div class="recommendations-list">
                    @foreach (var rec in recommendations.Take(3))
                    {
                        <span class="recommendation-item @(rec.IsPossibleAnswer ? "possible-answer" : "guess-only")"
                              title="Score: @rec.Score.ToString("F2") bits">@rec.Word.ToUpper()</span>
                    }
                </div>
            }
        </div>
    </div>

    <div class="filter-buttons">
        <button class="filter-btn unused-btn @(wordFilter == WordFilter.Unused ? "active" : "")" @onclick="() => SetFilter(WordFilter.Unused)">unused</button>
        <button class="filter-btn both-btn @(wordFilter == WordFilter.Both ? "active" : "")" @onclick="() => SetFilter(WordFilter.Both)">both</button>
        <button class="filter-btn used-btn @(wordFilter == WordFilter.Used ? "active" : "")" @onclick="() => SetFilter(WordFilter.Used)">used</button>
    </div>

        <div class="results">
            <h2>Matching Words (@GetFilteredWords().Count())</h2>
            <div class="word-list">
                @foreach (var word in GetFilteredWords())
                {
                    if (usedWords.ContainsKey(word))
                    {
                        var (gameNumber, date) = usedWords[word];
                        <span class="used-word" title="Game #@gameNumber - @date">@word</span>
                    }
                    else
                    {
                        <span class="word">@word</span>
                    }
                }
            </div>
        </div>
</div>

@code {
    private char[] letters = new char[5] { ' ', ' ', ' ', ' ', ' ' };
    private LetterState[] states = new LetterState[5];
    private bool[] lockedPositions = new bool[5];
    private int focusedIndex = 0;
    private List<string> allWords = new List<string>();
    private Dictionary<string, (int gameNumber, string date)> usedWords = new Dictionary<string, (int, string)>();
    private List<string> matchingWords = new List<string>();
    private DotNetObjectReference<Home>? dotNetRef;
    private WordFilter wordFilter = WordFilter.Both;
    private List<(char[] letters, LetterState[] states)> previousGuesses = new List<(char[], LetterState[])>();
    private List<WordleStrategyService.Recommendation>? recommendations = null;
    private StrategyMode strategyMode = StrategyMode.Off;
    private bool isLoadingRecommendations = false;

    // Wordle game info based on user's local date
    private DateTime userLocalDate = DateTime.Today; // Uses browser's local timezone
    private int currentWordleGameNumber = 0;
    private string currentWordleWord = string.Empty;
    private static readonly DateTime WordleStartDate = new DateTime(2021, 6, 19); // Wordle game 0

    private enum WordFilter
    {
        Unused,
        Both,
        Used
    }

    private enum StrategyMode
    {
        Off,
        Normal,
        Hard
    }

    protected override async Task OnInitializedAsync()
    {
        CalculateCurrentWordleGame();
        await LoadWordLists();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            dotNetRef = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("setupKeyboardListener", dotNetRef);
            await Task.Delay(100);
            await JSRuntime.InvokeVoidAsync("focusMobileInput");
        }
    }

    private async Task LoadWordLists()
    {
        try
        {
            // Load answer words first and display immediately
            var wordsText = await Http.GetStringAsync("words.txt");
            allWords = wordsText.Split('\n', StringSplitOptions.RemoveEmptyEntries)
                .Select(w => w.Trim().ToLower())
                .Where(w => w.Length == 5)
                .ToList();

            // Initialize with answer words and refresh display
            matchingWords = allWords.OrderBy(w => w).ToList();
            StateHasChanged();

            // Now load the rest of the data
            var usedCsv = await Http.GetStringAsync("used-words.csv");
            foreach (var line in usedCsv.Split('\n', StringSplitOptions.RemoveEmptyEntries))
            {
                var parts = line.Split(',');
                if (parts.Length >= 3)
                {
                    var word = parts[0].Trim().ToLower();
                    if (word.Length == 5 && int.TryParse(parts[1].Trim(), out int gameNumber))
                    {
                        var date = parts[2].Trim();
                        usedWords[word] = (gameNumber, date);
                    }
                }
            }

            // Load guess-only words for strategy service
            var guessOnlyWords = await Http.GetStringAsync("guess-only-words.txt");
            StrategyService.Initialize(wordsText, guessOnlyWords);

            // Pass used words to strategy service
            // Use current game number as cutoff so today's word (and future words) remain as possible answers
            StrategyService.LoadUsedWords(usedWords, currentWordleGameNumber);

            // Load pre-calculated starting words
            var startingWordsJson = await Http.GetStringAsync("starting-words.json");
            StrategyService.LoadStartingWords(startingWordsJson);

            // Final refresh after all data is loaded
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading word lists: {ex.Message}");
        }
    }

    private void CalculateCurrentWordleGame()
    {
        // Calculate days since Wordle started (game 0 was June 19, 2021)
        currentWordleGameNumber = (userLocalDate - WordleStartDate).Days;

        // Look up today's word from the used words database
        var todayWordEntry = usedWords.FirstOrDefault(w => w.Value.gameNumber == currentWordleGameNumber);
        if (!todayWordEntry.Equals(default(KeyValuePair<string, (int, string)>)))
        {
            currentWordleWord = todayWordEntry.Key;
        }
        else
        {
            currentWordleWord = string.Empty;
        }

        Console.WriteLine($"User's local date: {userLocalDate:yyyy-MM-dd}");
        Console.WriteLine($"Current Wordle game: #{currentWordleGameNumber}");
        Console.WriteLine($"Today's word: {(string.IsNullOrEmpty(currentWordleWord) ? "Unknown" : currentWordleWord.ToUpper())}");
    }

    [JSInvokable]
    public async void HandleKeyPress(string key)
    {
        if (focusedIndex < 0) return;

        // Skip locked (inherited) positions
        if (lockedPositions[focusedIndex])
        {
            MoveToNextEditablePosition();
            return;
        }

        char keyChar = key[0];
        letters[focusedIndex] = char.ToLower(keyChar);

        if (char.IsLower(keyChar))
        {
            states[focusedIndex] = LetterState.White;
        }
        else if (char.IsUpper(keyChar))
        {
            states[focusedIndex] = LetterState.Yellow;
        }
        else if (keyChar == ' ')
        {
            states[focusedIndex] = LetterState.None;
        }

        // Move to next editable box
        MoveToNextEditablePosition();

        CheckAndFilterWords();
        StateHasChanged();

        // Auto-recalculate recommendations for HARD mode on each letter change
        if (strategyMode == StrategyMode.Hard)
        {
            await CalculateRecommendations();
        }
    }

    private void MoveToNextEditablePosition()
    {
        // Move to next non-locked box if not at the end, or clear focus if at the end
        int nextIndex = focusedIndex + 1;
        while (nextIndex < 5 && lockedPositions[nextIndex])
        {
            nextIndex++;
        }

        if (nextIndex < 5)
        {
            focusedIndex = nextIndex;
        }
        else
        {
            focusedIndex = -1;
        }
    }

    [JSInvokable]
    public async void HandleBackspace()
    {
        // If no box is focused, focus the last non-locked box
        if (focusedIndex < 0)
        {
            focusedIndex = 4;
            while (focusedIndex >= 0 && lockedPositions[focusedIndex])
            {
                focusedIndex--;
            }
            if (focusedIndex < 0) return; // All boxes are locked
        }

        // Find the last non-locked (editable) box
        int lastEditableIndex = 4;
        while (lastEditableIndex >= 0 && lockedPositions[lastEditableIndex])
        {
            lastEditableIndex--;
        }

        // Check if there are any editable boxes before the current one
        bool hasEditableBoxBefore = false;
        for (int i = focusedIndex - 1; i >= 0; i--)
        {
            if (!lockedPositions[i])
            {
                hasEditableBoxBefore = true;
                break;
            }
        }

        // Check if we're on the last editable box and it has content
        bool isLastEditableBox = focusedIndex == lastEditableIndex;
        bool hadContent = letters[focusedIndex] != ' ';

        // Don't clear locked boxes
        if (!lockedPositions[focusedIndex])
        {
            letters[focusedIndex] = ' ';
            states[focusedIndex] = LetterState.None;
        }

        // Move to previous non-locked box unless:
        // 1. At the first position, OR
        // 2. No editable boxes before this one (it's the first editable box), OR
        // 3. On last editable box and it had content (stay on last box after deleting)
        if (focusedIndex > 0 && hasEditableBoxBefore && !(isLastEditableBox && hadContent))
        {
            focusedIndex--;
            while (focusedIndex >= 0 && lockedPositions[focusedIndex])
            {
                focusedIndex--;
            }
            if (focusedIndex < 0) focusedIndex = 0;
        }

        CheckAndFilterWords();
        StateHasChanged();

        // Auto-recalculate recommendations for HARD mode on letter delete
        if (strategyMode == StrategyMode.Hard)
        {
            await CalculateRecommendations();
        }
    }

    [JSInvokable]
    public void HandleArrowLeft()
    {
        // If no box is focused, focus the last non-locked box
        if (focusedIndex < 0)
        {
            focusedIndex = 4;
            while (focusedIndex >= 0 && lockedPositions[focusedIndex])
            {
                focusedIndex--;
            }
        }
        else if (focusedIndex > 0)
        {
            focusedIndex--;
            while (focusedIndex >= 0 && lockedPositions[focusedIndex])
            {
                focusedIndex--;
            }
        }
        StateHasChanged();
    }

    [JSInvokable]
    public void HandleArrowRight()
    {
        // If no box is focused, focus the first non-locked box
        if (focusedIndex < 0)
        {
            focusedIndex = 0;
            while (focusedIndex < 5 && lockedPositions[focusedIndex])
            {
                focusedIndex++;
            }
        }
        else if (focusedIndex < 4)
        {
            focusedIndex++;
            while (focusedIndex < 5 && lockedPositions[focusedIndex])
            {
                focusedIndex++;
            }
        }
        StateHasChanged();
    }

    private async void SetFocus(int index)
    {
        // Don't allow focusing on locked (inherited) boxes
        if (lockedPositions[index])
        {
            return;
        }

        focusedIndex = index;
        StateHasChanged();
        await JSRuntime.InvokeVoidAsync("focusMobileInput");
    }

    private async void CycleState(int index)
    {
        if (letters[index] != ' ' && !lockedPositions[index])
        {
            states[index] = states[index] switch
            {
                LetterState.White => LetterState.Yellow,
                LetterState.Yellow => LetterState.Green,
                LetterState.Green => LetterState.White,
                _ => LetterState.White
            };
            CheckAndFilterWords();
            StateHasChanged();

            // Auto-recalculate recommendations for HARD mode on letter state change
            if (strategyMode == StrategyMode.Hard)
            {
                await CalculateRecommendations();
            }
        }
    }

    private string GetStateButtonClass(int index)
    {
        // Button shows the color of the NEXT state
        return states[index] switch
        {
            LetterState.White => "yellow-btn",
            LetterState.Yellow => "green-btn",
            LetterState.Green => "white-btn",
            _ => "yellow-btn"
        };
    }

    private string GetStateButtonTooltip(int index)
    {
        // Tooltip indicates what color the button will change TO
        return states[index] switch
        {
            LetterState.White => "Change to Yellow",
            LetterState.Yellow => "Change to Green",
            LetterState.Green => "Change to White",
            _ => "Change to Yellow"
        };
    }

    private void CheckAndFilterWords()
    {
        // Filter words if at least one letter is entered OR if there are previous guesses
        if (letters.Any(l => l != ' ') || previousGuesses.Any())
        {
            FilterWords();
        }
        else
        {
            // Show all words when no letters are entered and no previous guesses
            matchingWords = allWords.OrderBy(w => w).ToList();
        }
    }

    private void FilterWords()
    {
        var guesses = new List<WordleFilterService.Guess>();

        // Add current entry if it has non-locked letters
        bool hasNonLockedLetters = false;
        for (int i = 0; i < 5; i++)
        {
            if (letters[i] != ' ' && !lockedPositions[i])
            {
                hasNonLockedLetters = true;
                break;
            }
        }

        if (hasNonLockedLetters)
        {
            guesses.Add(new WordleFilterService.Guess(letters, states));
        }

        // Add all previous guesses
        foreach (var (guessLetters, guessStates) in previousGuesses)
        {
            guesses.Add(new WordleFilterService.Guess(guessLetters, guessStates));
        }

        matchingWords = FilterService.FilterWords(allWords, guesses).ToList();
    }

    private string GetLetterClass(int index)
    {
        return states[index] switch
        {
            LetterState.White => "white",
            LetterState.Yellow => "yellow",
            LetterState.Green => "green",
            _ => ""
        };
    }

    private string GetLetterClassForState(LetterState state)
    {
        return state switch
        {
            LetterState.White => "white",
            LetterState.Yellow => "yellow",
            LetterState.Green => "green",
            _ => ""
        };
    }

    private async void AddGuess()
    {
        // Only add if at least one letter is entered
        if (letters.Any(l => l != ' '))
        {
            // Clone the current letters and states
            var guessLetters = (char[])letters.Clone();
            var guessStates = (LetterState[])states.Clone();
            previousGuesses.Add((guessLetters, guessStates));

            // Clear the entry boxes, but preserve green letters and mark them as locked
            for (int i = 0; i < 5; i++)
            {
                if (states[i] == LetterState.Green)
                {
                    // Keep green letter and mark as locked (inherited)
                    lockedPositions[i] = true;
                }
                else
                {
                    letters[i] = ' ';
                    states[i] = LetterState.None;
                    lockedPositions[i] = false;
                }
            }

            // Find first non-locked position to focus
            focusedIndex = 0;
            for (int i = 0; i < 5; i++)
            {
                if (!lockedPositions[i])
                {
                    focusedIndex = i;
                    break;
                }
            }

            CheckAndFilterWords();
            StateHasChanged();
            await JSRuntime.InvokeVoidAsync("focusMobileInput");
        }
    }

    private async void RemoveGuess(int index)
    {
        if (index >= 0 && index < previousGuesses.Count)
        {
            previousGuesses.RemoveAt(index);
            CheckAndFilterWords();
            StateHasChanged();

            // Auto-recalculate recommendations after removing a guess
            if (strategyMode != StrategyMode.Off)
            {
                await CalculateRecommendations();
            }
        }
    }

    private string GetFocusClass(int index)
    {
        return focusedIndex == index ? "focused" : "";
    }

    private void SetFilter(WordFilter filter)
    {
        wordFilter = filter;
        StateHasChanged();
    }

    private IEnumerable<string> GetFilteredWords()
    {
        return wordFilter switch
        {
            WordFilter.Unused => matchingWords.Where(w => !usedWords.ContainsKey(w)),
            WordFilter.Used => matchingWords.Where(w => usedWords.ContainsKey(w)),
            _ => matchingWords
        };
    }

    private async Task SetStrategyMode(StrategyMode mode)
    {
        strategyMode = mode;

        if (mode == StrategyMode.Off)
        {
            recommendations = null;
            StateHasChanged();
            return;
        }

        // Auto-calculate when switching to Normal or Hard
        await CalculateRecommendations();
    }

    private async Task CalculateRecommendations()
    {
        if (strategyMode == StrategyMode.Off) return;

        // Check if strategy service is initialized
        if (!StrategyService.IsInitialized)
        {
            Console.WriteLine("Strategy service not initialized yet");
            return;
        }

        // For HARD mode: show cached starting words if first guess and <5 letterboxes filled
        if (strategyMode == StrategyMode.Hard && previousGuesses.Count == 0)
        {
            int filledCount = letters.Count(l => l != ' ');
            if (filledCount < 5)
            {
                // Use cached starting words - pass empty guesses list
                recommendations = StrategyService.GetRecommendations(new List<WordleFilterService.Guess>(), hardMode: true, topN: 5);
                StateHasChanged();
                return;
            }
        }

        isLoadingRecommendations = true;
        StateHasChanged();

        await Task.Delay(1); // Allow UI to update

        try
        {
            var guesses = new List<WordleFilterService.Guess>();

            // Add all previous guesses
            foreach (var (guessLetters, guessStates) in previousGuesses)
            {
                guesses.Add(new WordleFilterService.Guess(guessLetters, guessStates));
            }

            // Add current entry if it has letters
            bool hasCurrentLetters = letters.Any(l => l != ' ');
            if (hasCurrentLetters)
            {
                guesses.Add(new WordleFilterService.Guess(letters, states));
            }

            bool isHardMode = strategyMode == StrategyMode.Hard;
            recommendations = StrategyService.GetRecommendations(guesses, isHardMode, topN: 5);

            Console.WriteLine($"Generated {recommendations?.Count ?? 0} recommendations");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error getting recommendations: {ex.Message}");
            recommendations = null;
        }
        finally
        {
            isLoadingRecommendations = false;
            StateHasChanged();
        }
    }

    public void Dispose()
    {
        dotNetRef?.Dispose();
    }
}
