@page "/"
@inject HttpClient Http
@inject IJSRuntime JSRuntime

<PageTitle>Wordle Match</PageTitle>

<div class="wordle-container">
    <h1>Wordle Match</h1>

    <input type="text" id="mobile-keyboard-input" class="mobile-keyboard-input" inputmode="text" autocapitalize="off" autocomplete="off" autocorrect="off" spellcheck="false" />

    @* Display previous guesses *@
    @for (int guessIndex = 0; guessIndex < previousGuesses.Count; guessIndex++)
    {
        var currentGuessIndex = guessIndex;
        var (guessLetters, guessStates) = previousGuesses[guessIndex];
        <div class="previous-guess-row">
            <div class="letter-boxes previous-guess">
                @for (int i = 0; i < 5; i++)
                {
                    int index = i;
                    <div class="letter-box-container">
                        <div class="letter-box @GetLetterClassForState(guessStates[index])">
                            @(guessLetters[index] == ' ' ? "" : guessLetters[index].ToString().ToUpper())
                        </div>
                    </div>
                }
            </div>
            <button class="delete-guess-btn" @onclick="() => RemoveGuess(currentGuessIndex)" title="Remove this guess">×</button>
        </div>
    }

    @* Current entry row *@
    <div class="entry-row">
        <div class="letter-boxes" id="letter-boxes-container">
            @for (int i = 0; i < 5; i++)
            {
                int index = i;
                <div class="letter-box-container">
                    <div class="letter-box @GetLetterClass(index) @GetFocusClass(index) @(lockedPositions[index] ? "locked" : "")" @onclick="() => SetFocus(index)">
                        @(letters[index] == ' ' ? "" : letters[index].ToString().ToUpper())
                    </div>
                    @if (letters[index] != ' ' && !lockedPositions[index])
                    {
                        <div class="button-group">
                            <button class="state-button @GetStateButtonClass(index)"
                                    title="@GetStateButtonTooltip(index)"
                                    @onclick="() => CycleState(index)"></button>
                        </div>
                    }
                </div>
            }
        </div>
        <button class="add-guess-btn" @onclick="AddGuess" title="add new guess">+</button>
    </div>

    <div class="instructions">
        Type letters from your Wordle guesses. Lowercase = excluded letter (white), Uppercase = letter in word but wrong position (yellow). Click the button to cycle through states. Press Space to leave a box empty (wildcard).
    </div>

    <div class="filter-buttons">
            <button class="filter-btn unused-btn @(wordFilter == WordFilter.Unused ? "active" : "")" @onclick="() => SetFilter(WordFilter.Unused)">unused</button>
            <button class="filter-btn both-btn @(wordFilter == WordFilter.Both ? "active" : "")" @onclick="() => SetFilter(WordFilter.Both)">both</button>
            <button class="filter-btn used-btn @(wordFilter == WordFilter.Used ? "active" : "")" @onclick="() => SetFilter(WordFilter.Used)">used</button>
        </div>

        <div class="results">
            <h2>Matching Words (@GetFilteredWords().Count())</h2>
            <div class="word-list">
                @foreach (var word in GetFilteredWords())
                {
                    if (usedWords.ContainsKey(word))
                    {
                        var (gameNumber, date) = usedWords[word];
                        <span class="used-word" title="Game #@gameNumber - @date">@word</span>
                    }
                    else
                    {
                        <span class="word">@word</span>
                    }
                }
            </div>
        </div>
</div>

@code {
    private char[] letters = new char[5] { ' ', ' ', ' ', ' ', ' ' };
    private LetterState[] states = new LetterState[5];
    private bool[] lockedPositions = new bool[5];
    private int focusedIndex = 0;
    private List<string> allWords = new List<string>();
    private Dictionary<string, (int gameNumber, string date)> usedWords = new Dictionary<string, (int, string)>();
    private List<string> matchingWords = new List<string>();
    private DotNetObjectReference<Home>? dotNetRef;
    private WordFilter wordFilter = WordFilter.Both;
    private List<(char[] letters, LetterState[] states)> previousGuesses = new List<(char[], LetterState[])>();

    private enum LetterState
    {
        None,
        White,
        Yellow,
        Green
    }

    private enum WordFilter
    {
        Unused,
        Both,
        Used
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadWordLists();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            dotNetRef = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("setupKeyboardListener", dotNetRef);
            await Task.Delay(100);
            await JSRuntime.InvokeVoidAsync("focusMobileInput");
        }
    }

    private async Task LoadWordLists()
    {
        try
        {
            var wordsText = await Http.GetStringAsync("words.txt");
            allWords = wordsText.Split('\n', StringSplitOptions.RemoveEmptyEntries)
                .Select(w => w.Trim().ToLower())
                .Where(w => w.Length == 5)
                .ToList();

            var usedCsv = await Http.GetStringAsync("used-words.csv");
            foreach (var line in usedCsv.Split('\n', StringSplitOptions.RemoveEmptyEntries))
            {
                var parts = line.Split(',');
                if (parts.Length >= 3)
                {
                    var word = parts[0].Trim().ToLower();
                    if (word.Length == 5 && int.TryParse(parts[1].Trim(), out int gameNumber))
                    {
                        var date = parts[2].Trim();
                        usedWords[word] = (gameNumber, date);
                    }
                }
            }

            // Initialize with all words
            matchingWords = allWords.OrderBy(w => w).ToList();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading word lists: {ex.Message}");
        }
    }

    [JSInvokable]
    public void HandleKeyPress(string key)
    {
        if (focusedIndex < 0) return;

        // Skip locked (inherited) positions
        if (lockedPositions[focusedIndex])
        {
            MoveToNextEditablePosition();
            return;
        }

        char keyChar = key[0];
        letters[focusedIndex] = char.ToLower(keyChar);

        if (char.IsLower(keyChar))
        {
            states[focusedIndex] = LetterState.White;
        }
        else if (char.IsUpper(keyChar))
        {
            states[focusedIndex] = LetterState.Yellow;
        }
        else if (keyChar == ' ')
        {
            states[focusedIndex] = LetterState.None;
        }

        // Move to next editable box
        MoveToNextEditablePosition();

        CheckAndFilterWords();
        StateHasChanged();
    }

    private void MoveToNextEditablePosition()
    {
        // Move to next non-locked box if not at the end, or clear focus if at the end
        int nextIndex = focusedIndex + 1;
        while (nextIndex < 5 && lockedPositions[nextIndex])
        {
            nextIndex++;
        }

        if (nextIndex < 5)
        {
            focusedIndex = nextIndex;
        }
        else
        {
            focusedIndex = -1;
        }
    }

    [JSInvokable]
    public void HandleBackspace()
    {
        // If no box is focused, focus the last non-locked box
        if (focusedIndex < 0)
        {
            focusedIndex = 4;
            while (focusedIndex >= 0 && lockedPositions[focusedIndex])
            {
                focusedIndex--;
            }
            if (focusedIndex < 0) return; // All boxes are locked
        }

        // Don't clear locked boxes
        if (!lockedPositions[focusedIndex])
        {
            letters[focusedIndex] = ' ';
            states[focusedIndex] = LetterState.None;
        }

        // Move to previous non-locked box unless at the first position
        if (focusedIndex > 0)
        {
            focusedIndex--;
            while (focusedIndex >= 0 && lockedPositions[focusedIndex])
            {
                focusedIndex--;
            }
            if (focusedIndex < 0) focusedIndex = 0;
        }

        CheckAndFilterWords();
        StateHasChanged();
    }

    [JSInvokable]
    public void HandleArrowLeft()
    {
        // If no box is focused, focus the last non-locked box
        if (focusedIndex < 0)
        {
            focusedIndex = 4;
            while (focusedIndex >= 0 && lockedPositions[focusedIndex])
            {
                focusedIndex--;
            }
        }
        else if (focusedIndex > 0)
        {
            focusedIndex--;
            while (focusedIndex >= 0 && lockedPositions[focusedIndex])
            {
                focusedIndex--;
            }
        }
        StateHasChanged();
    }

    [JSInvokable]
    public void HandleArrowRight()
    {
        // If no box is focused, focus the first non-locked box
        if (focusedIndex < 0)
        {
            focusedIndex = 0;
            while (focusedIndex < 5 && lockedPositions[focusedIndex])
            {
                focusedIndex++;
            }
        }
        else if (focusedIndex < 4)
        {
            focusedIndex++;
            while (focusedIndex < 5 && lockedPositions[focusedIndex])
            {
                focusedIndex++;
            }
        }
        StateHasChanged();
    }

    private async void SetFocus(int index)
    {
        // Don't allow focusing on locked (inherited) boxes
        if (lockedPositions[index])
        {
            return;
        }

        focusedIndex = index;
        StateHasChanged();
        await JSRuntime.InvokeVoidAsync("focusMobileInput");
    }

    private void CycleState(int index)
    {
        if (letters[index] != ' ' && !lockedPositions[index])
        {
            states[index] = states[index] switch
            {
                LetterState.White => LetterState.Yellow,
                LetterState.Yellow => LetterState.Green,
                LetterState.Green => LetterState.White,
                _ => LetterState.White
            };
            CheckAndFilterWords();
            StateHasChanged();
        }
    }

    private string GetStateButtonClass(int index)
    {
        // Button shows the color of the NEXT state
        return states[index] switch
        {
            LetterState.White => "yellow-btn",
            LetterState.Yellow => "green-btn",
            LetterState.Green => "white-btn",
            _ => "yellow-btn"
        };
    }

    private string GetStateButtonTooltip(int index)
    {
        // Tooltip indicates what color the button will change TO
        return states[index] switch
        {
            LetterState.White => "Change to Yellow",
            LetterState.Yellow => "Change to Green",
            LetterState.Green => "Change to White",
            _ => "Change to Yellow"
        };
    }

    private void CheckAndFilterWords()
    {
        // Filter words if at least one letter is entered OR if there are previous guesses
        if (letters.Any(l => l != ' ') || previousGuesses.Any())
        {
            FilterWords();
        }
        else
        {
            // Show all words when no letters are entered and no previous guesses
            matchingWords = allWords.OrderBy(w => w).ToList();
        }
    }

    private void FilterWords()
    {
        matchingWords = allWords.Where(word => MatchesPattern(word)).OrderBy(w => w).ToList();
    }

    private bool MatchesPattern(string word)
    {
        // Check current entry only if it has non-locked letters
        bool hasNonLockedLetters = false;
        for (int i = 0; i < 5; i++)
        {
            if (letters[i] != ' ' && !lockedPositions[i])
            {
                hasNonLockedLetters = true;
                break;
            }
        }

        if (hasNonLockedLetters)
        {
            if (!MatchesGuess(word, letters, states))
                return false;
        }

        // Check all previous guesses
        foreach (var (guessLetters, guessStates) in previousGuesses)
        {
            if (!MatchesGuess(word, guessLetters, guessStates))
                return false;
        }

        return true;
    }

    private bool MatchesGuess(string word, char[] letters, LetterState[] states)
    {
        // Count green/yellow instances of each letter
        var greenYellowCount = new Dictionary<char, int>();
        var whiteLetters = new HashSet<char>();

        for (int i = 0; i < 5; i++)
        {
            if (letters[i] == ' ' || states[i] == LetterState.None)
                continue;

            char letter = char.ToLower(letters[i]);

            if (states[i] == LetterState.Green || states[i] == LetterState.Yellow)
            {
                if (!greenYellowCount.ContainsKey(letter))
                    greenYellowCount[letter] = 0;
                greenYellowCount[letter]++;
            }
            else if (states[i] == LetterState.White)
            {
                whiteLetters.Add(letter);
            }
        }

        // Check position constraints
        for (int i = 0; i < 5; i++)
        {
            if (states[i] == LetterState.Green)
            {
                if (word[i] != char.ToLower(letters[i]))
                    return false;
            }
            else if (states[i] == LetterState.Yellow)
            {
                char letter = char.ToLower(letters[i]);
                if (!word.Contains(letter))
                    return false;
                if (word[i] == letter)
                    return false;
            }
        }

        // Check frequency constraints for white letters
        foreach (char letter in whiteLetters)
        {
            int actualCount = word.Count(c => c == letter);

            if (greenYellowCount.ContainsKey(letter))
            {
                // There are green/yellow instances, so word should have exactly that many
                if (actualCount != greenYellowCount[letter])
                    return false;
            }
            else
            {
                // No green/yellow instances, so word should not contain this letter at all
                if (actualCount > 0)
                    return false;
            }
        }

        // Check minimum frequency for green/yellow letters without white instances
        foreach (var (letter, minCount) in greenYellowCount)
        {
            if (!whiteLetters.Contains(letter))
            {
                // No white instance means word should have AT LEAST this many
                int actualCount = word.Count(c => c == letter);
                if (actualCount < minCount)
                    return false;
            }
        }

        return true;
    }

    private string GetLetterClass(int index)
    {
        return states[index] switch
        {
            LetterState.White => "white",
            LetterState.Yellow => "yellow",
            LetterState.Green => "green",
            _ => ""
        };
    }

    private string GetLetterClassForState(LetterState state)
    {
        return state switch
        {
            LetterState.White => "white",
            LetterState.Yellow => "yellow",
            LetterState.Green => "green",
            _ => ""
        };
    }

    private async void AddGuess()
    {
        // Only add if at least one letter is entered
        if (letters.Any(l => l != ' '))
        {
            // Clone the current letters and states
            var guessLetters = (char[])letters.Clone();
            var guessStates = (LetterState[])states.Clone();
            previousGuesses.Add((guessLetters, guessStates));

            // Clear the entry boxes, but preserve green letters and mark them as locked
            for (int i = 0; i < 5; i++)
            {
                if (states[i] == LetterState.Green)
                {
                    // Keep green letter and mark as locked (inherited)
                    lockedPositions[i] = true;
                }
                else
                {
                    letters[i] = ' ';
                    states[i] = LetterState.None;
                    lockedPositions[i] = false;
                }
            }

            // Find first non-locked position to focus
            focusedIndex = 0;
            for (int i = 0; i < 5; i++)
            {
                if (!lockedPositions[i])
                {
                    focusedIndex = i;
                    break;
                }
            }

            CheckAndFilterWords();
            StateHasChanged();
            await JSRuntime.InvokeVoidAsync("focusMobileInput");
        }
    }

    private void RemoveGuess(int index)
    {
        if (index >= 0 && index < previousGuesses.Count)
        {
            previousGuesses.RemoveAt(index);
            CheckAndFilterWords();
            StateHasChanged();
        }
    }

    private string GetFocusClass(int index)
    {
        return focusedIndex == index ? "focused" : "";
    }

    private void SetFilter(WordFilter filter)
    {
        wordFilter = filter;
        StateHasChanged();
    }

    private IEnumerable<string> GetFilteredWords()
    {
        return wordFilter switch
        {
            WordFilter.Unused => matchingWords.Where(w => !usedWords.ContainsKey(w)),
            WordFilter.Used => matchingWords.Where(w => usedWords.ContainsKey(w)),
            _ => matchingWords
        };
    }

    public void Dispose()
    {
        dotNetRef?.Dispose();
    }
}
