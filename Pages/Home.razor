@page "/"
@inject HttpClient Http
@inject IJSRuntime JSRuntime
@inject WordleHelper.Services.WordleFilterService FilterService
@inject WordleHelper.Services.WordleStrategyService StrategyService
@using WordleHelper.Services
@using LetterState = WordleHelper.Services.WordleFilterService.LetterState

<PageTitle>Wordle Match</PageTitle>

<div class="wordle-container">
    <div class="theme-toggle">
        <button class="theme-btn" @onclick="ToggleTheme" title="Toggle dark mode" aria-label="Toggle dark mode">
            @(isDarkMode ? "☀️" : "🌙")
        </button>
    </div>

    <h1>Wordle Match</h1>

    <input type="text" id="mobile-keyboard-input" class="mobile-keyboard-input" inputmode="text" autocapitalize="off" autocomplete="off" autocorrect="off" spellcheck="false" />

    @* Display previous guesses *@
    @for (int guessIndex = 0; guessIndex < previousGuesses.Count; guessIndex++)
    {
        var currentGuessIndex = guessIndex;
        var (guessLetters, guessStates) = previousGuesses[guessIndex];
        <div class="previous-guess-row">
            <div class="letter-boxes previous-guess">
                @for (int i = 0; i < 5; i++)
                {
                    int index = i;
                    <div class="letter-box-container">
                        <div class="letter-box @GetLetterClassForState(guessStates[index])">
                            @(guessLetters[index] == ' ' ? "" : guessLetters[index].ToString().ToUpper())
                        </div>
                    </div>
                }
            </div>
            <button class="delete-guess-btn" @onclick="() => RemoveGuess(currentGuessIndex)" title="Remove this guess">×</button>
        </div>
    }

    @* Current entry row *@
    <div class="entry-row">
        <div class="letter-boxes" id="letter-boxes-container">
            @for (int i = 0; i < 5; i++)
            {
                int index = i;
                <div class="letter-box-container">
                    <div class="letter-box @GetLetterClass(index) @GetFocusClass(index) @(lockedPositions[index] ? "locked" : "")"
                         tabindex="@(index + 1)"
                         @onclick="() => SetFocus(index)">
                        @(letters[index] == ' ' ? "" : letters[index].ToString().ToUpper())
                    </div>
                    @if (letters[index] != ' ' && !lockedPositions[index])
                    {
                        <div class="button-group">
                            <button class="state-button @GetStateButtonClass(index)"
                                    tabindex="@(7 + index)"
                                    title="@GetStateButtonTooltip(index)"
                                    @onclick="() => CycleState(index)"></button>
                        </div>
                    }
                </div>
            }
        </div>
        <button class="add-guess-btn" id="add-guess-btn" tabindex="6" @onclick="AddGuess" title="add new guess">+</button>
    </div>

    <div class="instructions">
        Type letters from your Wordle guesses. Lowercase = excluded letter (white), Uppercase = letter in word but wrong position (yellow). Click the button to cycle through states. Press Space to leave a box empty (wildcard).
    </div>

    <div class="puzzle-info-container">
        <div class="puzzle-info">
            <button class="history-button" @onclick="OpenHistoryCalendar" title="Play past puzzles">
                <span class="material-icons">history</span>
            </button>
            <span class="puzzle-date">@userLocalDate.ToString("MMMM d, yyyy")</span>
            <span class="puzzle-separator">•</span>
            @if (!string.IsNullOrEmpty(currentWordleWord))
            {
                <span class="puzzle-number">Puzzle #@currentWordleGameNumber</span>
            }
            else
            {
                <span class="puzzle-number">Today's word not loaded</span>
            }
        </div>
    </div>

    <div class="recommendations-section">
        <div class="recommendations-header">
            <span class="recommendations-label">Recommendations:</span>
            <div class="mode-toggle">
                <button class="mode-btn @(strategyMode == StrategyMode.Off ? "active" : "")" @onclick="() => SetStrategyMode(StrategyMode.Off)">Off</button>
                @* <button class="mode-btn @(strategyMode == StrategyMode.Normal ? "active" : "")" @onclick="() => SetStrategyMode(StrategyMode.Normal)">Normal</button> *@
                <button class="mode-btn @(strategyMode == StrategyMode.Hard ? "active" : "")" @onclick="() => SetStrategyMode(StrategyMode.Hard)">Hard</button>
            </div>
            @if (isLoadingRecommendations)
            {
                <span class="loading-indicator">Calculating...</span>
            }
            else if (isRefiningRecommendations)
            {
                <span class="refining-indicator">✨</span>
            }
            else if (strategyMode != StrategyMode.Off && recommendations != null && recommendations.Any())
            {
                <div class="recommendations-list">
                    @foreach (var rec in GetDisplayRecommendations())
                    {
                        <span class="recommendation-item @(rec.IsPossibleAnswer ? "possible-answer" : "guess-only")"
                              title="Score: @rec.Score.ToString("F2") bits">@rec.Word.ToUpper()</span>
                    }
                </div>
            }
        </div>
    </div>

    <div class="recommendations-section hints-section">
        <div class="recommendations-header">
            <span class="recommendations-label">Hints:</span>
            <div class="mode-toggle">
                <button class="mode-btn @(selectedHint == HintType.Vowels ? "active" : "")" @onclick="() => SetHint(HintType.Vowels)" disabled="@string.IsNullOrEmpty(currentWordleWord)">Vowels</button>
                <button class="mode-btn @(selectedHint == HintType.Synonym ? "active" : "")" @onclick="() => SetHint(HintType.Synonym)" disabled="@string.IsNullOrEmpty(currentWordleWord)">Synonym</button>
                <button class="mode-btn @(selectedHint == HintType.Haiku ? "active" : "")" @onclick="() => SetHint(HintType.Haiku)" disabled="@string.IsNullOrEmpty(currentWordleWord)">Haiku</button>
                <button class="mode-btn @(selectedHint == HintType.Reveal ? "active" : "")" @onclick="() => SetHint(HintType.Reveal)" disabled="@string.IsNullOrEmpty(currentWordleWord)">Reveal</button>
            </div>
        </div>
        @if (selectedHint != null && !string.IsNullOrEmpty(currentWordleWord))
        {
            <div class="hint-display">
                @if (selectedHint == HintType.Vowels)
                {
                    <span>Contains @currentWordVowelCount vowel@(currentWordVowelCount == 1 ? "" : "s")</span>
                }
                else if (selectedHint == HintType.Synonym && !string.IsNullOrEmpty(currentWordSynonym))
                {
                    <span>@currentWordSynonym</span>
                }
                else if (selectedHint == HintType.Haiku && !string.IsNullOrEmpty(currentWordHaiku))
                {
                    <div class="haiku-text">@currentWordHaiku.Replace(" / ", "\n")</div>
                }
                else if (selectedHint == HintType.Reveal)
                {
                    @if (!revealConfirmed)
                    {
                        <button class="reveal-confirm-btn" @onclick="ConfirmReveal">Are you sure?</button>
                    }
                    else
                    {
                        <span class="reveal-word">@currentWordleWord.ToUpper()</span>
                    }
                }
            </div>
        }
    </div>

    <div class="filter-buttons">
        <button class="filter-btn unused-btn @(wordFilter == WordFilter.Unused ? "active" : "")" @onclick="() => SetFilter(WordFilter.Unused)">unused</button>
        <button class="filter-btn both-btn @(wordFilter == WordFilter.Both ? "active" : "")" @onclick="() => SetFilter(WordFilter.Both)">both</button>
        <button class="filter-btn used-btn @(wordFilter == WordFilter.Used ? "active" : "")" @onclick="() => SetFilter(WordFilter.Used)">used</button>
    </div>

        <div class="results">
            <h2>Matching Words (@GetFilteredWords().Count())</h2>
            <div class="word-list">
                @foreach (var word in GetFilteredWords())
                {
                    if (usedWords.ContainsKey(word))
                    {
                        var (gameNumber, date) = usedWords[word];
                        // Only show as "used" if the game number is before today's game
                        if (gameNumber < currentWordleGameNumber)
                        {
                            <span class="used-word" title="Game #@gameNumber - @date">@word</span>
                        }
                        else
                        {
                            <span class="word">@word</span>
                        }
                    }
                    else
                    {
                        <span class="word">@word</span>
                    }
                }
            </div>
        </div>
</div>

<CalendarModal
    IsOpen="@showCalendarModal"
    SelectedDate="@userLocalDate"
    UsedWords="@usedWords"
    OnDateSelected="@OnHistoricalDateSelected"
    OnClose="@(() => showCalendarModal = false)" />

@code {
    private char[] letters = new char[5] { ' ', ' ', ' ', ' ', ' ' };
    private LetterState[] states = new LetterState[5];
    private bool[] lockedPositions = new bool[5];
    private int focusedIndex = 0;
    private List<string> allWords = new List<string>();
    private Dictionary<string, (int gameNumber, string date)> usedWords = new Dictionary<string, (int, string)>();
    private List<string> matchingWords = new List<string>();
    private DotNetObjectReference<Home>? dotNetRef;
    private WordFilter wordFilter = WordFilter.Both;
    private List<(char[] letters, LetterState[] states)> previousGuesses = new List<(char[], LetterState[])>();
    private List<WordleStrategyService.Recommendation>? recommendations = null;
    private StrategyMode strategyMode = StrategyMode.Off;
    private bool isLoadingRecommendations = false;
    private bool isRefiningRecommendations = false;
    private bool isDarkMode = false;
    private bool showCalendarModal = false;

    // Wordle game info based on user's local date
    private DateTime userLocalDate = DateTime.Today; // Uses browser's local timezone
    private int currentWordleGameNumber = 0;
    private string currentWordleWord = string.Empty;
    private static readonly DateTime WordleStartDate = new DateTime(2021, 6, 19); // Wordle game 0

    // Hints for today's word
    private Dictionary<string, (string synonym, string haiku)> wordHints = new Dictionary<string, (string, string)>();
    private string currentWordSynonym = string.Empty;
    private string currentWordHaiku = string.Empty;
    private int currentWordVowelCount = 0;
    private HintType? selectedHint = null;
    private bool revealConfirmed = false;

    private enum HintType
    {
        Vowels,
        Synonym,
        Haiku,
        Reveal
    }

    private enum WordFilter
    {
        Unused,
        Both,
        Used
    }

    private enum StrategyMode
    {
        Off,
        Normal,
        Hard
    }

    private IEnumerable<WordleStrategyService.Recommendation> GetDisplayRecommendations()
    {
        if (recommendations == null || !recommendations.Any())
            return Enumerable.Empty<WordleStrategyService.Recommendation>();

        var top3 = recommendations.Take(3).ToList();

        // Check if any of the top 3 are solution words
        if (top3.Any(r => r.IsPossibleAnswer))
            return top3;

        // If none of the top 3 are solution words, find the first solution word in positions 4-5
        var solutionWord = recommendations.Skip(3).Take(2).FirstOrDefault(r => r.IsPossibleAnswer);

        if (solutionWord != null)
        {
            // Replace the 3rd recommendation with the solution word
            return new[] { top3[0], top3[1], solutionWord };
        }

        // No solution words in top 5, return top 3 as-is
        return top3;
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadWordLists();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            dotNetRef = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("setupKeyboardListener", dotNetRef);
            await Task.Delay(100);
            await JSRuntime.InvokeVoidAsync("focusMobileInput");

            // Initialize theme based on localStorage or system preference
            await InitializeTheme();
        }
    }

    private async Task LoadWordLists()
    {
        try
        {
            // Load answer words first and display immediately
            var wordsText = await Http.GetStringAsync("words.txt");
            allWords = wordsText.Split('\n', StringSplitOptions.RemoveEmptyEntries)
                .Select(w => w.Trim().ToLower())
                .Where(w => w.Length == 5)
                .ToList();

            // Initialize with answer words and refresh display
            matchingWords = allWords.OrderBy(w => w).ToList();
            StateHasChanged();

            // Now load the rest of the data
            var usedCsv = await Http.GetStringAsync("used-words.csv");
            foreach (var line in usedCsv.Split('\n', StringSplitOptions.RemoveEmptyEntries))
            {
                var parts = line.Split(',');
                if (parts.Length >= 3)
                {
                    var word = parts[0].Trim().ToLower();
                    if (word.Length == 5 && int.TryParse(parts[1].Trim(), out int gameNumber))
                    {
                        var date = parts[2].Trim();
                        usedWords[word] = (gameNumber, date);
                    }
                }
            }

            // Now that usedWords is loaded, calculate today's word
            CalculateCurrentWordleGame();

            // Load guess-only words for strategy service
            var guessOnlyWords = await Http.GetStringAsync("guess-only-words.txt");
            StrategyService.Initialize(wordsText, guessOnlyWords);

            // Pass used words to strategy service
            // Use current game number as cutoff so today's word (and future words) remain as possible answers
            StrategyService.LoadUsedWords(usedWords, currentWordleGameNumber);

            // Load pre-calculated starting words
            var startingWordsJson = await Http.GetStringAsync("starting-words.json");
            StrategyService.LoadStartingWords(startingWordsJson);

            // Load high-quality words for Normal mode optimization
            var highQualityWordsJson = await Http.GetStringAsync("high-quality-words.json");
            StrategyService.LoadHighQualityWords(highQualityWordsJson);

            // Load second-word cache for instant second-guess recommendations (Phase 2B)
            // This file is optional - if not found, live calculation will be used
            try
            {
                var secondWordCacheJson = await Http.GetStringAsync("second-word-cache.json");
                StrategyService.LoadSecondWordCache(secondWordCacheJson);
            }
            catch
            {
                // Cache file not found - will use live calculation
                Console.WriteLine("Second-word cache not found, using live calculation");
            }

            // Load word hints (synonym and haiku)
            await LoadWordHints();

            // Look up hints for today's word now that hints are loaded
            LookupCurrentWordHints();

            // Final refresh after all data is loaded
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading word lists: {ex.Message}");
        }
    }

    private async Task LoadWordHints()
    {
        try
        {
            // Load word hints (only contains hints for words that have been added)
            var hintsCsv = await Http.GetStringAsync("word-hints.csv");
            foreach (var line in hintsCsv.Split('\n', StringSplitOptions.RemoveEmptyEntries))
            {
                var parts = line.Split(',', 3); // Split into max 3 parts to handle commas in haiku
                if (parts.Length >= 3 && parts[0] != "word") // Skip header
                {
                    var word = parts[0].Trim().ToLower();
                    var synonym = parts[1].Trim();
                    var haiku = parts[2].Trim().Trim('"'); // Remove quotes if present
                    wordHints[word] = (synonym, haiku);
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading word hints: {ex.Message}");
        }
    }

    private void CalculateCurrentWordleGame()
    {
        // Calculate days since Wordle started (game 0 was June 19, 2021)
        currentWordleGameNumber = (userLocalDate - WordleStartDate).Days;

        // Look up today's word from the used words database
        var todayWordEntry = usedWords.FirstOrDefault(w => w.Value.gameNumber == currentWordleGameNumber);
        if (!todayWordEntry.Equals(default(KeyValuePair<string, (int, string)>)))
        {
            currentWordleWord = todayWordEntry.Key;
            currentWordVowelCount = CountVowels(currentWordleWord);
        }
        else
        {
            currentWordleWord = string.Empty;
            currentWordVowelCount = 0;
        }
    }

    private void OpenHistoryCalendar()
    {
        showCalendarModal = true;
    }

    private void OnHistoricalDateSelected(DateTime selectedDate)
    {
        userLocalDate = selectedDate;
        showCalendarModal = false;

        // Reset the game with the new date
        CalculateCurrentWordleGame();
        LookupCurrentWordHints();
        FilterWords();
        StateHasChanged();
    }

    private int CountVowels(string word)
    {
        if (string.IsNullOrEmpty(word)) return 0;

        var vowels = new[] { 'a', 'e', 'i', 'o', 'u' };
        return word.ToLower().Count(c => vowels.Contains(c));
    }

    private void LookupCurrentWordHints()
    {
        // Look up hints for today's word (call this after hints are loaded)
        if (!string.IsNullOrEmpty(currentWordleWord))
        {
            var lookupWord = currentWordleWord.ToLower(); // Convert to lowercase for lookup
            if (wordHints.ContainsKey(lookupWord))
            {
                var hints = wordHints[lookupWord];
                currentWordSynonym = hints.synonym;
                currentWordHaiku = hints.haiku;
            }
            else
            {
                currentWordSynonym = string.Empty;
                currentWordHaiku = string.Empty;
            }
        }
        else
        {
            currentWordSynonym = string.Empty;
            currentWordHaiku = string.Empty;
        }
    }

    [JSInvokable]
    public async void HandleKeyPress(string key)
    {
        if (focusedIndex < 0) return;

        // Skip locked (inherited) positions
        if (lockedPositions[focusedIndex])
        {
            MoveToNextEditablePosition();
            return;
        }

        char keyChar = key[0];
        letters[focusedIndex] = char.ToLower(keyChar);

        if (char.IsLower(keyChar))
        {
            states[focusedIndex] = LetterState.White;
        }
        else if (char.IsUpper(keyChar))
        {
            states[focusedIndex] = LetterState.Yellow;
        }
        else if (keyChar == ' ')
        {
            states[focusedIndex] = LetterState.None;
        }

        // Move to next editable box
        MoveToNextEditablePosition();

        CheckAndFilterWords();
        StateHasChanged();

        // Auto-recalculate recommendations for HARD and NORMAL mode on each letter change
        if (strategyMode != StrategyMode.Off)
        {
            await CalculateRecommendations();
        }
    }

    private async void MoveToNextEditablePosition()
    {
        // Move to next non-locked box if not at the end, or focus + button if at the end
        int nextIndex = focusedIndex + 1;
        while (nextIndex < 5 && lockedPositions[nextIndex])
        {
            nextIndex++;
        }

        if (nextIndex < 5)
        {
            focusedIndex = nextIndex;
        }
        else
        {
            focusedIndex = -1;
            // Focus the + button after filling all boxes
            await JSRuntime.InvokeVoidAsync("focusAddGuessButton");
        }
    }

    [JSInvokable]
    public async void HandleBackspace()
    {
        // If no box is focused, focus the last non-locked box
        if (focusedIndex < 0)
        {
            focusedIndex = 4;
            while (focusedIndex >= 0 && lockedPositions[focusedIndex])
            {
                focusedIndex--;
            }
            if (focusedIndex < 0) return; // All boxes are locked
        }

        // Find the last non-locked (editable) box
        int lastEditableIndex = 4;
        while (lastEditableIndex >= 0 && lockedPositions[lastEditableIndex])
        {
            lastEditableIndex--;
        }

        // Check if there are any editable boxes before the current one
        bool hasEditableBoxBefore = false;
        for (int i = focusedIndex - 1; i >= 0; i--)
        {
            if (!lockedPositions[i])
            {
                hasEditableBoxBefore = true;
                break;
            }
        }

        // Check if current box has content
        bool hadContent = letters[focusedIndex] != ' ';

        if (hadContent)
        {
            // Box has content: delete it and stay on this box
            if (!lockedPositions[focusedIndex])
            {
                letters[focusedIndex] = ' ';
                states[focusedIndex] = LetterState.None;
            }
        }
        else
        {
            // Box is empty: move back one box and delete its content
            if (focusedIndex > 0 && hasEditableBoxBefore)
            {
                focusedIndex--;
                while (focusedIndex >= 0 && lockedPositions[focusedIndex])
                {
                    focusedIndex--;
                }
                if (focusedIndex < 0)
                {
                    focusedIndex = 0;
                }
                else if (!lockedPositions[focusedIndex])
                {
                    // Clear the box we moved to
                    letters[focusedIndex] = ' ';
                    states[focusedIndex] = LetterState.None;
                }
            }
        }

        CheckAndFilterWords();
        StateHasChanged();

        // Auto-recalculate recommendations for HARD and NORMAL mode on letter delete
        if (strategyMode != StrategyMode.Off)
        {
            await CalculateRecommendations();
        }
    }

    [JSInvokable]
    public void HandleArrowLeft()
    {
        // If no box is focused, focus the last non-locked box
        if (focusedIndex < 0)
        {
            focusedIndex = 4;
            while (focusedIndex >= 0 && lockedPositions[focusedIndex])
            {
                focusedIndex--;
            }
        }
        else if (focusedIndex > 0)
        {
            focusedIndex--;
            while (focusedIndex >= 0 && lockedPositions[focusedIndex])
            {
                focusedIndex--;
            }
        }
        StateHasChanged();
    }

    [JSInvokable]
    public void HandleArrowRight()
    {
        // If no box is focused, focus the first non-locked box
        if (focusedIndex < 0)
        {
            focusedIndex = 0;
            while (focusedIndex < 5 && lockedPositions[focusedIndex])
            {
                focusedIndex++;
            }
        }
        else if (focusedIndex < 4)
        {
            focusedIndex++;
            while (focusedIndex < 5 && lockedPositions[focusedIndex])
            {
                focusedIndex++;
            }
        }
        StateHasChanged();
    }

    private async void SetFocus(int index)
    {
        // Don't allow focusing on locked (inherited) boxes
        if (lockedPositions[index])
        {
            return;
        }

        focusedIndex = index;
        StateHasChanged();
        await JSRuntime.InvokeVoidAsync("focusMobileInput");
    }

    private async void CycleState(int index)
    {
        if (letters[index] != ' ' && !lockedPositions[index])
        {
            states[index] = states[index] switch
            {
                LetterState.White => LetterState.Yellow,
                LetterState.Yellow => LetterState.Green,
                LetterState.Green => LetterState.White,
                _ => LetterState.White
            };
            CheckAndFilterWords();
            StateHasChanged();

            // Auto-recalculate recommendations for HARD and NORMAL mode on letter state change
            if (strategyMode != StrategyMode.Off)
            {
                await CalculateRecommendations();
            }
        }
    }

    private string GetStateButtonClass(int index)
    {
        // Button shows the color of the NEXT state
        return states[index] switch
        {
            LetterState.White => "yellow-btn",
            LetterState.Yellow => "green-btn",
            LetterState.Green => "white-btn",
            _ => "yellow-btn"
        };
    }

    private string GetStateButtonTooltip(int index)
    {
        // Tooltip indicates what color the button will change TO
        return states[index] switch
        {
            LetterState.White => "Change to Yellow",
            LetterState.Yellow => "Change to Green",
            LetterState.Green => "Change to White",
            _ => "Change to Yellow"
        };
    }

    private void CheckAndFilterWords()
    {
        // Filter words if at least one letter is entered OR if there are previous guesses
        if (letters.Any(l => l != ' ') || previousGuesses.Any())
        {
            FilterWords();
        }
        else
        {
            // Show all words when no letters are entered and no previous guesses
            matchingWords = allWords.OrderBy(w => w).ToList();
        }
    }

    private void FilterWords()
    {
        var guesses = new List<WordleFilterService.Guess>();

        // Add current entry if it has non-locked letters
        bool hasNonLockedLetters = false;
        for (int i = 0; i < 5; i++)
        {
            if (letters[i] != ' ' && !lockedPositions[i])
            {
                hasNonLockedLetters = true;
                break;
            }
        }

        if (hasNonLockedLetters)
        {
            guesses.Add(new WordleFilterService.Guess(letters, states));
        }

        // Add all previous guesses
        foreach (var (guessLetters, guessStates) in previousGuesses)
        {
            guesses.Add(new WordleFilterService.Guess(guessLetters, guessStates));
        }

        matchingWords = FilterService.FilterWords(allWords, guesses).ToList();
    }

    private string GetLetterClass(int index)
    {
        return states[index] switch
        {
            LetterState.White => "white",
            LetterState.Yellow => "yellow",
            LetterState.Green => "green",
            _ => ""
        };
    }

    private string GetLetterClassForState(LetterState state)
    {
        return state switch
        {
            LetterState.White => "white",
            LetterState.Yellow => "yellow",
            LetterState.Green => "green",
            _ => ""
        };
    }

    private async void AddGuess()
    {
        // Only add if at least one letter is entered
        if (letters.Any(l => l != ' '))
        {
            // Clone the current letters and states
            var guessLetters = (char[])letters.Clone();
            var guessStates = (LetterState[])states.Clone();
            previousGuesses.Add((guessLetters, guessStates));

            // Clear the entry boxes, but preserve green letters and mark them as locked
            for (int i = 0; i < 5; i++)
            {
                if (states[i] == LetterState.Green)
                {
                    // Keep green letter and mark as locked (inherited)
                    lockedPositions[i] = true;
                }
                else
                {
                    letters[i] = ' ';
                    states[i] = LetterState.None;
                    lockedPositions[i] = false;
                }
            }

            // Find first non-locked position to focus
            focusedIndex = 0;
            for (int i = 0; i < 5; i++)
            {
                if (!lockedPositions[i])
                {
                    focusedIndex = i;
                    break;
                }
            }

            CheckAndFilterWords();
            StateHasChanged();
            await JSRuntime.InvokeVoidAsync("focusMobileInput");
        }
    }

    private async void RemoveGuess(int index)
    {
        if (index >= 0 && index < previousGuesses.Count)
        {
            previousGuesses.RemoveAt(index);
            CheckAndFilterWords();
            StateHasChanged();

            // Auto-recalculate recommendations after removing a guess
            if (strategyMode != StrategyMode.Off)
            {
                await CalculateRecommendations();
            }
        }
    }

    private string GetFocusClass(int index)
    {
        return focusedIndex == index ? "focused" : "";
    }

    private void SetFilter(WordFilter filter)
    {
        wordFilter = filter;
        StateHasChanged();
    }

    private void SetHint(HintType hint)
    {
        // Toggle hint: if already selected, deselect it; otherwise select it
        selectedHint = selectedHint == hint ? null : hint;

        // Reset reveal confirmation when switching hints
        revealConfirmed = false;

        StateHasChanged();
    }

    private void ConfirmReveal()
    {
        revealConfirmed = true;
        StateHasChanged();
    }

    private IEnumerable<string> GetFilteredWords()
    {
        return wordFilter switch
        {
            // Unused: words not in usedWords OR words with game number >= current game
            WordFilter.Unused => matchingWords.Where(w =>
                !usedWords.ContainsKey(w) ||
                usedWords[w].gameNumber >= currentWordleGameNumber),
            // Used: words in usedWords AND with game number < current game
            WordFilter.Used => matchingWords.Where(w =>
                usedWords.ContainsKey(w) &&
                usedWords[w].gameNumber < currentWordleGameNumber),
            _ => matchingWords
        };
    }

    private async Task SetStrategyMode(StrategyMode mode)
    {
        strategyMode = mode;

        if (mode == StrategyMode.Off)
        {
            recommendations = null;
            StateHasChanged();
            return;
        }

        // Auto-calculate when switching to Normal or Hard
        await CalculateRecommendations();
    }

    private async Task CalculateRecommendations()
    {
        if (strategyMode == StrategyMode.Off) return;

        // Check if strategy service is initialized
        if (!StrategyService.IsInitialized)
        {
            Console.WriteLine("Strategy service not initialized yet");
            return;
        }

        // For HARD and NORMAL mode: show cached starting words if first guess and <5 letterboxes filled
        // This prevents expensive calculations while user is typing their first word
        if (previousGuesses.Count == 0)
        {
            int filledCount = letters.Count(l => l != ' ');
            if (filledCount < 5)
            {
                // Use cached starting words - pass empty guesses list
                bool isHardMode = strategyMode == StrategyMode.Hard;
                recommendations = StrategyService.GetRecommendations(new List<WordleFilterService.Guess>(), hardMode: isHardMode, topN: 5);
                StateHasChanged();
                return;
            }
        }

        isLoadingRecommendations = true;
        isRefiningRecommendations = false;
        StateHasChanged();

        await Task.Delay(1); // Allow UI to update

        try
        {
            var guesses = new List<WordleFilterService.Guess>();

            // Add all previous guesses
            foreach (var (guessLetters, guessStates) in previousGuesses)
            {
                guesses.Add(new WordleFilterService.Guess(guessLetters, guessStates));
            }

            // Add current entry if it has letters
            bool hasCurrentLetters = letters.Any(l => l != ' ');
            if (hasCurrentLetters)
            {
                guesses.Add(new WordleFilterService.Guess(letters, states));
            }

            bool isHardMode = strategyMode == StrategyMode.Hard;

            // Phase 1: Quick evaluation for instant feedback
            recommendations = StrategyService.GetRecommendationsQuick(guesses, isHardMode, topN: 5);
            isLoadingRecommendations = false;
            isRefiningRecommendations = true;  // Show refining indicator
            StateHasChanged();

            Console.WriteLine($"Quick: Generated {recommendations?.Count ?? 0} recommendations");

            // Phase 2: Full evaluation in background (only if not already cached)
            // Skip refinement if we got cached results (which are already optimal)
            bool isCachedResult = (guesses.Count == 0) ||
                                  (guesses.Count == 1 && !isHardMode);

            if (!isCachedResult)
            {
                await Task.Delay(1); // Allow UI to update with quick results

                var fullRecommendations = StrategyService.GetRecommendationsFull(guesses, isHardMode, topN: 5);

                // Update only if full recommendations are different/better
                if (AreBetterRecommendations(fullRecommendations, recommendations))
                {
                    recommendations = fullRecommendations;
                    StateHasChanged();
                    Console.WriteLine($"Full: Updated with {recommendations?.Count ?? 0} refined recommendations");
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error getting recommendations: {ex.Message}");
            recommendations = null;
        }
        finally
        {
            isLoadingRecommendations = false;
            isRefiningRecommendations = false;
            StateHasChanged();
        }
    }

    /// <summary>
    /// Checks if new recommendations are better than current ones
    /// Returns true if they're different and worth updating the UI
    /// </summary>
    private bool AreBetterRecommendations(
        List<WordleStrategyService.Recommendation>? newRecs,
        List<WordleStrategyService.Recommendation>? currentRecs)
    {
        if (newRecs == null || currentRecs == null)
            return false;

        if (newRecs.Count != currentRecs.Count)
            return true;

        // Check if top recommendation changed
        if (newRecs[0].Word != currentRecs[0].Word)
            return true;

        // Check if any scores improved significantly (>1% difference)
        for (int i = 0; i < Math.Min(newRecs.Count, currentRecs.Count); i++)
        {
            var scoreDiff = Math.Abs(newRecs[i].Score - currentRecs[i].Score);
            if (scoreDiff > 0.01)
                return true;
        }

        return false;
    }

    private async Task InitializeTheme()
    {
        try
        {
            // Check if there's a saved theme preference in localStorage
            var savedTheme = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "theme");

            if (!string.IsNullOrEmpty(savedTheme))
            {
                // Use saved preference
                isDarkMode = savedTheme == "dark";
            }
            else
            {
                // Check system preference
                var systemTheme = await JSRuntime.InvokeAsync<string>("getSystemThemePreference");
                isDarkMode = systemTheme == "dark";
            }

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error initializing theme: {ex.Message}");
        }
    }

    private async Task ToggleTheme()
    {
        isDarkMode = !isDarkMode;
        await ApplyTheme();
    }

    private async Task ApplyTheme()
    {
        try
        {
            var theme = isDarkMode ? "dark" : "light";

            // Save preference to localStorage
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", "theme", theme);

            // Apply theme to DOM
            await JSRuntime.InvokeVoidAsync("setTheme", theme);

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error applying theme: {ex.Message}");
        }
    }

    public void Dispose()
    {
        dotNetRef?.Dispose();
    }
}
